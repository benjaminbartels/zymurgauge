package simulation

import (
	"fmt"
	"time"

	"github.com/benjaminbartels/zymurgauge/internal/platform/log"

	"github.com/benjaminbartels/zymurgauge/internal"
)

type Chamber struct {
	Thermostat              *internal.Thermostat
	beerThermometer         *Thermometer
	chiller                 *Actuator
	heater                  *Actuator
	lastUpdate              time.Time
	logger                  log.Logger
	factor                  int
	wallTemp                float64
	airTemp                 float64
	beerTemp                float64
	environmentTemp         float64
	heaterTemp              float64
	beerCapacity            float64
	airCapacity             float64
	wallCapacity            float64
	heaterCapacity          float64
	heaterPower             float64
	coolerPower             float64
	airBeerTransfer         float64
	wallAirTransfer         float64
	heaterAirTransfer       float64
	environmentWallTransfer float64
	heaterToBeer            float64
	heaterToAir             float64
}

func NewChamber(thermostat *internal.Thermostat, beerThermometer *Thermometer,
	chiller, heater *Actuator, logger log.Logger) *Chamber {
	c := &Chamber{
		Thermostat:      thermostat,
		beerThermometer: beerThermometer,
		chiller:         chiller,
		heater:          heater,
		wallTemp:        20.0,
		airTemp:         20.0,
		beerTemp:        beerThermometer.currentTemp,
		environmentTemp: 20.0,
		heaterTemp:      20.0,
		logger:          logger,
	}

	c.chiller.update = c.update
	c.chiller.log = c.log
	c.heater.update = c.update
	c.heater.log = c.log

	c.beerCapacity = 4.2 * 1.0 * 20       // heat capacity water * density of water * 20L volume (in kJ per kelvin).
	c.airCapacity = 1.005 * 1.225 * 0.200 // heat capacity of dry air * density of air * 200L volume (in kJ per kelvin).
	// Moist air has only slightly higher heat capacity, 1.02 when saturated at 20C.
	c.wallCapacity = 5.0   // just a guess
	c.heaterCapacity = 1.0 // also a guess, to simulate that heater first heats itself, then starts heating the air

	c.heaterPower = 0.1 // 100W, in kW.
	c.coolerPower = 0.1 // 100W, in kW. Assuming 200W at 50% efficiency

	c.airBeerTransfer = 1.0 / 300
	c.wallAirTransfer = 1.0 / 300
	c.heaterAirTransfer = 1.0 / 30
	c.environmentWallTransfer = 0.001 // losses to environment

	c.heaterToBeer = 0.0 // ratio of heater transferred directly to beer instead of fridge air
	c.heaterToAir = 1.0 - c.heaterToBeer

	return c
}

func (c *Chamber) update() {

	for i := 0; i < 600; i++ {

		beerTempNew := c.beerTemp
		airTempNew := c.airTemp
		wallTempNew := c.wallTemp
		heaterTempNew := c.heaterTemp

		beerTempNew += (c.airTemp - c.beerTemp) * c.airBeerTransfer / c.beerCapacity

		if c.chiller.isOn {
			wallTempNew -= c.coolerPower / c.wallCapacity
		} else if c.heater.isOn {
			heaterTempNew += c.heaterPower / c.heaterCapacity
		}

		airTempNew += (c.heaterTemp - c.airTemp) * c.heaterAirTransfer / c.airCapacity
		airTempNew += (c.wallTemp - c.airTemp) * c.wallAirTransfer / c.airCapacity
		airTempNew += (c.beerTemp - c.airTemp) * c.airBeerTransfer / c.airCapacity

		beerTempNew += (c.airTemp - c.beerTemp) * c.airBeerTransfer / c.beerCapacity

		heaterTempNew += (c.airTemp - c.heaterTemp) * c.heaterAirTransfer / c.heaterCapacity

		wallTempNew += (c.environmentTemp - c.wallTemp) * c.environmentWallTransfer / c.wallCapacity
		wallTempNew += (c.airTemp - c.wallTemp) * c.wallAirTransfer / c.wallCapacity

		c.airTemp = airTempNew
		c.beerTemp = beerTempNew
		c.wallTemp = wallTempNew
		c.heaterTemp = heaterTempNew

		//sim yeast fermenting heat
		//c.beerTemp = c.beerTemp + 0.00005

		c.beerThermometer.currentTemp = c.beerTemp

		c.lastUpdate = time.Now()

	}
}

func (c *Chamber) log(s string) {
	if c.logger != nil {
		c.logger.Println(s)
	}
}

type Thermometer struct {
	currentTemp float64
}

func NewThermometer(startingTemp float64) *Thermometer {
	t := &Thermometer{
		currentTemp: startingTemp,
	}
	return t
}

func (t *Thermometer) Read() (*float64, error) {
	return &t.currentTemp, nil
}

type Actuator struct {
	Name   string
	isOn   bool
	update func()
	log    func(s string)
}

func (a *Actuator) On() error {
	a.log(fmt.Sprintf("%s On", a.Name))
	a.isOn = true
	a.update()
	return nil
}

func (a *Actuator) Off() error {
	a.log(fmt.Sprintf("%s Off", a.Name))
	a.isOn = false
	return nil
}
